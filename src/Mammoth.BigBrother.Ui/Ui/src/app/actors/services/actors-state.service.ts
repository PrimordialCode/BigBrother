import { Injectable, OnDestroy } from '@angular/core';
import { select, Store } from '@ngrx/store';
import { BehaviorSubject, interval, Observable, Subscription } from 'rxjs';
import { filter, map, switchMap } from 'rxjs/operators';
import { IActorInfoDto, ICounterDto } from '../../models/endpoint-web-api.models';
import { ActorsDisplayActor, ActorsGetGlobalCounters, ActorsLoadHierarcy } from '../../store/actions';
import { getActorsGlobalCounters, getActorsHierarchy, getSelectedActor } from '../../store/selectors';
import { IAppState } from '../../store/state';
import { ActorDetailService } from './actor-detail.service';

/**
 * A service that will manage all the Actors information for a single endpoint:
 * - it will wraps all the operations for a specifc endpoint.
 * - it will expose the actual actors hierarchy state
 *   that can be used by several components.
 * - the actual state of the service is held globally in ngrx/store.
 * - this is a convenient way to use the same observables in diffent components
 *   that need to access the data in the same way, because will take full advantage
 *   of ngrx selectors memoization (that will be break if we create the same selectors
 *   passing different props object *instances*).
 * - remember that memoization works for each couple (selector instance, props instance).
 *
 * Warning:
 * - it's always better try not to create multiple instance of the observables
 *   because Angular might not destroy and recreate the component, so the binding might not
 *   be fully evaluated again if we use OnPush strategy, the correct approach is to
 *   keep the observable alive and emit new values (or use switchMap to generate new inner
 *   observables).
 *
 * the service must be registered in the providers list of the compoenent
 * it will be used with (it should not be singleton), there can be multiple instances
 * of this service each monitoring a different endpoint.
 */
@Injectable()
export class ActorsStateService implements OnDestroy {
  private _endpointName$ = new BehaviorSubject<string>(null);
  private _endpointName: string; // might be replaced by this._endpointName$.getValue()

  private _hierarchy$: Observable<IActorInfoDto>;
  public get hierarchy$() {
    return this._hierarchy$;
  }

  private _globalCounters$: Observable<ICounterDto[]>;
  public get globalCounters$() {
    return this._globalCounters$;
  }

  private _selectedActor$: Observable<string>;
  public get selectedActor$() {
    return this._selectedActor$;
  }

  private _intervalSubscription: Subscription;

  constructor(
    private store: Store<IAppState>
  ) {
    // We use the switchMap operator to create observables we
    // can 'safely' bind to whenever the endpoint changes.
    // This way all the "| async" will subscribe to the observable generated by
    // the switch map (no new observable instances will be generated like in the previous
    // init funciton call implementation).

    // map the param value so every ngrx selector will receive the
    // same instance of the parameter object, this will make the
    // underlying selectors memoization work properly
    const endpoint$ = this._endpointName$.pipe(
      filter(data => data != null),
      map(data => ({ endpointName: data }))
    );

    this._hierarchy$ = endpoint$.pipe(
      switchMap(p => this.store.pipe(
        select(getActorsHierarchy(), p),
        filter(data => data != null),
        map(data => data.hierarchy)
      ))
    );

    this._globalCounters$ = endpoint$.pipe(
      switchMap(p => this.store.pipe(
        select(getActorsGlobalCounters(), p),
        filter(data => data != null),
        map(data => data.counters)
      ))
    );

    this._selectedActor$ = endpoint$.pipe(
      switchMap(p => this.store.pipe(
        select(getSelectedActor(), p)
      ))
    );

    /*
    with the followinf implementation memoization will not work properly:
    we pass different objects to the same underlying selector

    this._hierarchy$ = activatedRoute.params.pipe(
      switchMap(p => this.store.pipe(
        select(getActorsHierarchy(), { endpointName: p.name }),
        filter(data => data != null),
        map(data => data.hierarchy)
      ))
    );

    this._globalCounters$ = activatedRoute.params.pipe(
      switchMap(p => this.store.pipe(
        select(getActorsGlobalCounters(), { endpointName: p.name }),
        filter(data => data != null),
        map(data => data.counters)
      ))
    );

    this._selectedActor$ = activatedRoute.params.pipe(
      switchMap(p => this.store.pipe(
        select(getSelectedActor(), { endpointName: p.name })
      ))
    );
    */
  }

  ngOnDestroy(): void {
    this.resetIntervalSubscription();
  }

  private resetIntervalSubscription() {
    if (this._intervalSubscription != null) {
      this._intervalSubscription.unsubscribe();
      this._intervalSubscription = null;
    }
  }

  public init(endpointName: string) {
    this.resetIntervalSubscription();

    this._endpointName$.next(endpointName);
    this._endpointName = endpointName;

    // pass the same argument to have the memoization work!
    // const props = { endpointName: this._endpointName };

    /*
    this._hierarchy$ = this.store.pipe(
      select(getActorsHierarchy(), props),
      filter(data => data != null),
      map(data => data.hierarchy)
    );

    this._globalCounters$ = this.store.pipe(
      select(getActorsGlobalCounters(), props),
      filter(data => data != null),
      map(data => data.counters)
    );

    this._selectedActor$ = this.store.pipe(
      select(getSelectedActor(), props)
    );
    */

    this.refresh();
    // show the last displayed actor (the one we still have in the store)
    // this.displayActor(null);

    this._intervalSubscription = interval(5000).subscribe(() => this.refresh());
  }

  public refresh() {
    this.store.dispatch(new ActorsGetGlobalCounters(this._endpointName));
    this.store.dispatch(new ActorsLoadHierarcy(this._endpointName));
  }

  public displayActor(id: string) {
    this.store.dispatch(new ActorsDisplayActor(this._endpointName, id));
  }

  public createActorDetailService(id: string): ActorDetailService {
    return new ActorDetailService(
      this._endpointName,
      id,
      this.store
    );
  }
}
